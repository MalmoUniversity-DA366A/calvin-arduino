# Calvin RT2RT Protocol## Invite a RT to join the mesh![](join.svg "Join sequence")### `JOIN_REQUEST`    {      "cmd": "JOIN_REQUEST",       "serializers": [        "json"      ],       "id": "<sender runtime id>",       "sid": "<message id>"    }### `JOIN_REPLY`    {      "cmd": "JOIN_REPLY",       "serializer": "json",       "id": "<replier runtime id>",       "sid": "<message id replied to>"    }## Set up a tunnel to the newly joined RT![](tunnel.svg)### `TUNNEL_NEW`    {      "from_rt_uuid": "<runtime id>",       "cmd": "TUNNEL_NEW",       "tunnel_id": "<tunnel id>",       "to_rt_uuid": "<dest runtime id>",       "policy": {}, # unused      "type": "token", # what will be tunneled      "msg_uuid": "<message id>"    }### `REPLY`    {      "to_rt_uuid": "<dest runtime id>", # who should receive it       "from_rt_uuid": "<runtime id>", # who sent it      "cmd": "REPLY",       "value": <reply>,       "msg_uuid": "<message id replied to>"    }### A note about the reply valueReply value usually `ACK` or `NACK`, but for  `TUNNEL_NEW`    {      "status": "ACK",      "tunnel_id": "<tunnel id>"    }and for `PORT_CONNECT`    {        "reply": "ACK",         "port_id": "<id of remote port>"    } ## Migrate an actor to the new RT![](migrate.svg)  ### `ACTOR_NEW`This action creates a sink actor (without outports)    {      "to_rt_uuid": "<destination runtime id>",       "from_rt_uuid": "<sender runtime id>",       "state": {        "prev_connections": {          "actor_name": "<name of this actor>",           "inports": {            "<id of port>": [              "<id of runtime with remote port>",               "<id of remote port>"            ]          },           "actor_id": "<id of this actor>",           "outports": {}        },         "actor_type": "<type of this actor>",         "actor_state": {          "tokens": [], # internal data, can be ignored           "name": "<name of this actor>",           "inports": {            "<port name>": {              "name": "<port name>",               "fifo": { < internal data, can be ignored >},               "id": "<id of this port>"            }          },           "<actor variable>": <value>,           "<actor variable>": <value>,  # etc          "_managed": [ < internal data, can be ignored > ],          "outports": {},           "id": "<id of this actor>"        }      },       "cmd": "ACTOR_NEW",       "msg_uuid": "<message id>"    }### `PORT_CONNECT`    {      "from_rt_uuid": "<source runtime id>",       "peer_port_id": "<remove port id>",       "peer_actor_id": "<remove actor id>", # or null       "cmd": "PORT_CONNECT",       "peer_port_name": "<remove port name>", # or null       "tunnel_id": "<tunnel id to connect ports over>",       "to_rt_uuid": "<destination runtiume id>",       "peer_port_dir": "<direction of remote port (in/out)>", # or null       "port_id": "<id of local port>",       "msg_uuid": "<message id>"    }## Sending and receiving tokens  ![](recv_token.svg)![](send_token.svg)### `TUNNEL_DATA`     {      "to_rt_uuid": "<destination runtime id>",       "from_rt_uuid": "<sender runtime id>",       "cmd": "TUNNEL_DATA",       "value": <value>, # depends on type of tunnel, and if a reply, see below       "tunnel_id": "<tunnel id>"    }### `TOKEN`    {        "sequencenbr": <token #, to ensure continuity>,         "token": {          "type": "Token",           "data": <token data - number, string, etc>        },         "cmd": "TOKEN",         "port_id": "<local receiving port id>",         "peer_port_id": "<sending port id>"    }### `TOKEN_REPLY`    {        "sequencenbr": <token # this is a reply to>,         "peer_port_id": "<sending port id>",         "cmd": "TOKEN_REPLY",         "port_id": "<local receiving port id>",         "value": "ACK" # ACK for received, NACK for resend    }